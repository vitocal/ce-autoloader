<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>CEAutoLoader Integration Tests</title>
    <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
    <style>
        :root {
            --color-primary: #e31;
            --color-secondary: rgb(0 172 172 / 34%);
            --color-accent: #333;
            --color-bg-dark: #ddd;
            --color-bg: #eee;
            --color-bg-light: #fff;
            --color-fg: #333;
        }

        #fixtures {
            display: grid;
            width: auto;
            height: 320px;
            align-content: center;
            gap: 8px;
            justify-items: center;
            justify-content: center;
            margin: 50px;
            border: 1px solid gray;
        }

        #errors:empty {
            display: none;
        }

        :not(:defined) {
            display: block;
            border: 1px dashed var(--color-accent);
            background-color: var(--color-secondary);
            color: var(--color-fg);
            opacity: 0.8;
            width: auto;
            min-height: 1em;
            padding: 1em 0.5em;
            border-radius: 0.33em;
        }
    </style>
</head>

<body>
    <div id="mocha"></div>
    <div id="fixtures"></div>
    <div id="errors" style="color: red; background: #fee; padding: 1em; white-space: pre;"></div>

    <script src="https://unpkg.com/mocha/mocha.js"></script>

    <script>
        window.onerror = function (msg, url, line, col, error) {
            document.getElementById('errors').textContent += `Error: ${msg}\nAt: ${url}:${line}:${col}\nStack: ${error?.stack}\n\n`;
        };
        window.addEventListener('unhandledrejection', function (event) {
            document.getElementById('errors').textContent += `Unhandled Rejection: ${event.reason}\n\n`;
        });
    </script>

    <script class="mocha-init">
        mocha.setup('bdd');
        mocha.checkLeaks();
    </script>

    <script type="module">
        import { expect } from "https://esm.sh/chai@5.1.2";
        import { html, signal } from "https://esm.sh/uhtml";
        import AutoLoader from '../src/index.ts';

        class BaseComp extends HTMLElement {
            connectedCallback() {
                this.setAttribute('data-upgraded', 'true');
                this.appendChild(this.render())
            }

            render() {
                return html`Hello World`;
            }
        };

        // Component catalog
        const catalog = {
            "test-component": async () => {
                customElements.define('test-component', BaseComp);
            },
            "nested-component": async () => {
                class NestedComponent extends BaseComp { };
                customElements.define('nested-component', NestedComponent);
            },
            "dynamic-component": async () => {
                class DynamicComponent extends BaseComp { };
                customElements.define('dynamic-component', DynamicComponent);
            },
            "manual-component": async () => {
                class ManualComponent extends BaseComp { };
                customElements.define('manual-component', ManualComponent);
            },
            "interaction-component": async () => {
                class InteractionComponent extends BaseComp { };
                customElements.define('interaction-component', InteractionComponent);
            },
            "visible-component": async () => {
                class VisibleComponent extends BaseComp { };
                customElements.define('visible-component', VisibleComponent);
            },
        };

        describe('CEAutoLoader', () => {
            let registry;
            const fixtures = document.getElementById('fixtures');

            beforeEach(() => {
                fixtures.innerHTML = '';

                // Reset observers, but we can't really unregister the custom elements.
                registry?.clean();
                registry = undefined;

            });

            it('should upgrade existing components on start', async () => {
                const el = document.createElement('test-component');
                fixtures.appendChild(el);

                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                });
                await registry.discover();

                expect(el.hasAttribute('data-upgraded')).to.be.true;
            });

            it('should upgrade nested components', async () => {
                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                    observe: true
                });
                await registry.discover();

                const container = document.createElement('div');
                const el = document.createElement('nested-component');
                container.appendChild(el);
                fixtures.appendChild(container);

                await customElements.whenDefined("nested-component");

                expect(el.hasAttribute('data-upgraded')).to.be.true;
            });

            it('should upgrade dynamically added components (MutationObserver)', async () => {
                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                    observe: true
                });
                await registry.discover();


                const el = document.createElement('dynamic-component');
                fixtures.appendChild(el);

                // Wait for MutationObserver and async hydration
                await customElements.whenDefined("dynamic-component");

                expect(el.hasAttribute('data-upgraded')).to.be.true;
            });


            describe("loading attribute", () => {
                it('should allow manual', async () => {
                    const el = document.createElement('manual-component')
                    el.setAttribute('loading', 'manual');
                    fixtures.appendChild(el);

                    registry = new AutoLoader({
                        catalog,
                        root: fixtures,
                        observe: false,
                    });
                    await registry.discover();

                    expect(el.hasAttribute('data-upgraded')).to.be.false;

                    await registry.upgrade("manual");

                    expect(el.hasAttribute('data-upgraded')).to.be.true;
                });

                it('should allow interaction', async () => {
                    const el = document.createElement('interaction-component')
                    el.setAttribute('loading', 'interaction');
                    fixtures.appendChild(el);

                    registry = new AutoLoader({
                        catalog,
                        root: fixtures,
                    });
                    await registry.discover();

                    expect(el.hasAttribute('data-upgraded')).to.be.false;

                    await el.dispatchEvent(new PointerEvent('pointerdown'));
                    await customElements.whenDefined("interaction-component");

                    expect(el.hasAttribute('data-upgraded')).to.be.true;
                });

                it('should allow lazy', async () => {
                    const el = document.createElement('visible-component')
                    el.setAttribute('loading', 'lazy');
                    fixtures.appendChild(el);

                    registry = new AutoLoader({
                        catalog,
                        root: fixtures,
                        observe: false,
                    });
                    await registry.discover();

                    expect(el.hasAttribute('data-upgraded')).to.be.false;
                    await customElements.whenDefined("visible-component");
                    expect(el.hasAttribute('data-upgraded')).to.be.true;
                });
            });
        });


        describe("CEAutoLoader registry", () => {
            let registry;
            const fixtures = document.getElementById('fixtures');

            beforeEach(() => {
                fixtures.innerHTML = '';

                // Reset observers, but we can't really unregister the custom elements.
                registry?.clean();
                registry = undefined;
            });

            it("should allow .catalog to be updated after initialization", async () => {
                const el = document.createElement("after-component");
                fixtures.appendChild(el);

                registry = new AutoLoader({
                    catalog: {},
                    root: fixtures,
                    fallback: false
                });
                await registry.upgrade()

                expect(registry.catalog).to.be.a("Object");
                expect(el.hasAttribute("data-upgraded")).to.be.false;

                registry.catalog["after-component"] = async () => {
                    class AfterComponent extends BaseComp { }
                    customElements.define("after-component", AfterComponent);
                };
                await registry.upgrade()

                expect(el.hasAttribute("data-upgraded")).to.be.true;
            });

            it("Loader full-name: URL", async () => {
                const el = document.createElement("vi-hello")
                fixtures.appendChild(el);

                const catalog = {
                    "vi-hello": "/src/components/vi/vi-hello.ts"
                }

                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                });
                await registry.upgrade()

                await customElements.whenDefined("vi-hello");
                expect(customElements.get("vi-hello")).to.be.a("function");
            });
            it("Loader full-name: Function", async () => {
                const el = document.createElement("function-loader")
                fixtures.appendChild(el);

                const catalog = {
                    "function-loader": async (full_name) => {
                        class FunctionLoader extends BaseComp {
                            render() {
                                return html`<p>Registered with name <b>${full_name}</b></p>`
                            }
                        };
                        customElements.define("function-loader", FunctionLoader);
                        return FunctionLoader
                    }
                }

                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                });
                await registry.upgrade()

                await customElements.whenDefined("function-loader");
                expect(el.innerHTML).to.include("Registered with name <b>function-loader</b>");
            });
            it("Loader namespace-*: Function", async () => {
                const el = document.createElement("ns-anything")
                const el2 = document.createElement("ns-whatever")
                fixtures.appendChild(el);
                fixtures.appendChild(el2);

                /**
                 * The interesting part, using namespaces to load
                 * component libraries, or any other kind of component.
                 *
                 * Here, we render any component named ns-* as a <p> tag.
                 */
                const catalog = {
                    "ns-*": async (full_name) => {
                        const [namespace, name] = full_name.split('-');
                        class NamespaceLoader extends BaseComp {
                            render() {
                                return html`<p>Registered with name <b>${full_name}</b></p>`
                            }
                        };
                        customElements.define(`ns-${name}`, NamespaceLoader);
                        return NamespaceLoader
                    }
                }

                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                });

                await registry.upgrade();

                expect(el.innerHTML).to.include("Registered with name <b>ns-anything</b>");
                expect(el2.innerHTML).to.include("Registered with name <b>ns-whatever</b>");
            });
        });

        describe("Observability", () => {
            let registry;
            const fixtures = document.getElementById('fixtures');

            beforeEach(() => {
                fixtures.innerHTML = '';

                // Reset observers, but we can't really unregister the custom elements.
                registry?.clean();
                registry = undefined;
            });


            it("should create performance measurement load:${component-name}", async () => {
                const el = document.createElement("perf-test");
                fixtures.appendChild(el);

                const catalog = {
                    "perf-test": async () => {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        class PerfTest extends BaseComp { }
                        customElements.define("perf-test", PerfTest);
                    }
                };

                registry = new AutoLoader({
                    catalog,
                    root: fixtures,
                });
                await registry.upgrade();

                await customElements.whenDefined("perf-test");

                const entries = performance.getEntriesByName("load:perf-test");
                expect(entries).to.have.lengthOf.at.least(1);
                expect(entries[0].entryType).to.equal("measure");
                expect(entries[0].duration).to.be.at.least(100);
            });

        });

        mocha.run();
    </script>
</body>

</html>