(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&s(n)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();const w="modulepreload",y=function(o){return"/ce-autoloader/"+o},h={},L=function(e,t,s){let i=Promise.resolve();if(t&&t.length>0){let d=function(c){return Promise.all(c.map(u=>Promise.resolve(u).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};document.getElementsByTagName("link");const n=document.querySelector("meta[property=csp-nonce]"),a=n?.nonce||n?.getAttribute("nonce");i=d(t.map(c=>{if(c=y(c),c in h)return;h[c]=!0;const u=c.endsWith(".css"),f=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${f}`))return;const l=document.createElement("link");if(l.rel=u?"stylesheet":w,u||(l.as="script"),l.crossOrigin="",l.href=c,a&&l.setAttribute("nonce",a),document.head.appendChild(l),u)return new Promise((E,b)=>{l.addEventListener("load",E),l.addEventListener("error",()=>b(new Error(`Unable to preload CSS for ${c}`)))})}))}function r(n){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=n,window.dispatchEvent(a),!a.defaultPrevented)throw n}return i.then(n=>{for(const a of n||[])a.status==="rejected"&&r(a.reason);return e().catch(r)})};class m extends Error{constructor(e,t){super(`CEAutoLoader: ${e}`),this.details=t}}function p(o){return o instanceof HTMLElement&&o.tagName.includes("-")}function v(o,e=300){let t;return function(...s){clearTimeout(t),t=setTimeout(()=>o.apply(this,s),e)}}function g(o){const e=":not(:defined)";return[...new Set([o,...o.querySelectorAll(e)])].filter(t=>p(t))}class _{constructor(e){if(this._catalog={},this._namespaces={},this.#e={},this.#t=!1,console.log("CEAutoLoader started with options:",e),!e.catalog)throw new Error("CEAutoLoader needs a catalog to start");this.options={live:!0,root:document.body,directives:["eager","visible","interaction"],defaultDirective:"eager",...e},this.catalog=e.catalog,globalThis.DEFINE||D()}#e;#t;get catalog(){return this._catalog}set catalog(e){this._catalog=e,this._namespaces=Object.fromEntries(Object.entries(this._catalog).filter(([t])=>t.endsWith("-*")).map(([t,s])=>[t.split("-")[0],s]))}watch(){const e=new MutationObserver(v(this.watcher.bind(this),100));e.observe(this.options.root||document.body,{childList:!0,subtree:!0,characterData:!0}),this.#e.mutation=e}async watcher(e){console.log("mutated",e);for(const t of e)if(t.type==="childList")for(const s of t.addedNodes)s.nodeType==1&&s instanceof HTMLElement&&(p(s)||g(s).length>0)&&await this.discover()}filterByDirective(e,t){return t?e.filter(s=>s.getAttribute("on")==t):e.filter(s=>!s.hasAttribute("on"))}uniqueByTag(e){const t=new Set,s=[];for(const i of e){const r=i.tagName;t.has(r)||(t.add(r),s.push(i))}return s}clean(){Object.entries(this.#e).map(([e,t])=>t.disconnect()),this.#e={}}async discover(){!this.#t&&this.options.live&&this.watch();for(const t of this.options.directives??[])this.upgrade(t);const e=await this.upgrade();return console.log("finished discover",e),this.#t=!0,e}async upgrade(e){const t=g(this.options.root||document.body),i=this.filterByDirective(t,e);return e==="visible"||this.options.defaultDirective==="visible"?(this.#e.intersection||(this.#e.intersection=new IntersectionObserver(r=>{r.filter(n=>!customElements.get(n.target.tagName.toLowerCase())).filter(n=>n.isIntersecting).map(n=>this.loadAndDefine([n.target],"visible"))})),console.log("observing intersection of",i),i.map(r=>this.#e.intersection.observe(r)),i):e==="interaction"||this.options.defaultDirective==="interaction"?i.map(r=>r.addEventListener("pointerdown",()=>{this.loadAndDefine([r],"interaction")},{once:!0})):e==="eager"||this.options.defaultDirective==="eager"?await this.loadAndDefine(i,"eager"):await this.loadAndDefine(i,"default")}async loadAndDefine(e,t){console.log(`registering from ${t}`,e.map(n=>n.tagName.toLowerCase()));const s=await Promise.allSettled(e.map(n=>this.load(n))),i=s.filter(n=>n.status==="fulfilled"),r=s.filter(n=>n.status==="rejected");return this.options.fallback&&await Promise.allSettled(r.map(n=>{const a=n.reason.details;let d=class extends this.options.fallback{};a.el.setAttribute("error",n.reason.message),a.el.setAttribute("stack",n.reason.stack),this.define({name:a.name,el:a.el,module:d})})),await Promise.allSettled([...i.map(n=>this.define(n.value)),this.flushDefine()]),s}async load(e){const t=e.tagName.toLowerCase();let s=this._catalog[t]||this.getNamespace(t);if(!s)throw new m(`Component ${t} not found in catalog`,{name:t,el:e});let i;try{if(performance.mark(`load:${t}:start`),e.setAttribute("ce-loading",""),typeof s=="string")i=await import(s);else if(typeof s=="function")i=await s(t);else throw new m(`Loader of ${t} is invalid! Should be a url or a function`,{name:t,el:e,module:i})}finally{e.removeAttribute("ce-loading"),performance.mark(`load:${t}:end`),performance.measure(`load:${t}`,`load:${t}:start`,`load:${t}:end`)}return{name:t,module:i,asset:s,el:e}}async define({name:e,el:t,module:s}){if(!customElements.get(e)){if(customElements.waiting[e])s=customElements.waiting[e].ctor;else{if(!s)throw new m(`Component ${e} wasn't registered! This is a bug!!!`,{name:e,el:t,module:s});s=s?.prototype instanceof HTMLElement?s:s?.default}try{performance.mark(`define:${e}:start`),t.setAttribute("ce-defined",""),DEFINE(e,s,{})}finally{performance.mark(`define:${e}:end`),performance.measure(`define:${e}`,`define:${e}:start`,`define:${e}:end`)}return{name:e,module:s}}}getNamespace(e){const[t,s]=e.split("-");return this._namespaces[t]}flushDefine(){console.log("flushDefine()",Object.keys(customElements.waiting)),Object.keys(customElements.waiting).length>0&&Object.entries(customElements.waiting).filter(([e])=>!customElements.get(e)).map(([e,{ctor:t,options:s}])=>DEFINE(e,t,s))}}function D(){globalThis._DEFINE=customElements.define.bind(customElements),globalThis.DEFINE=(o,e,t)=>{globalThis._DEFINE(o,e,t),customElements.registered[o]={ctor:e,options:t},delete customElements.waiting[o]},customElements.waiting={},customElements.registered={},customElements.define=function(o,e,t){customElements.waiting[o]={ctor:e,options:t}}}export{_ as C,L as _};
