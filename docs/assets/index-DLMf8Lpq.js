(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const n of o.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function t(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=t(s);fetch(s.href,o)}})();class c extends Error{constructor(e,t){super(`CEAutoLoader: ${e}`),this.details=t}}function f(r){return r instanceof HTMLElement&&r.tagName.includes("-")}function d(r,e=300){let t;return function(...i){clearTimeout(t),t=setTimeout(()=>r.apply(this,i),e)}}function l(r){const e=":not(:defined)";return[...new Set([r,...r.querySelectorAll(e)])].filter(t=>f(t))}class g{constructor(e){if(this._catalog={},this._namespaces={},this.#e={},this.#t=!1,console.log("CEAutoLoader started with options:",e),!e.catalog)throw new Error("CEAutoLoader needs a catalog to start");this.options={live:!0,root:document.body,directives:["eager","visible","interaction"],defaultDirective:"eager",...e},this.catalog=e.catalog,globalThis.DEFINE||m()}#e;#t;get catalog(){return this._catalog}set catalog(e){this._catalog=e,this._namespaces=Object.fromEntries(Object.entries(this._catalog).filter(([t])=>t.endsWith("-*")).map(([t,i])=>[t.split("-")[0],i]))}watch(){const e=new MutationObserver(d(this.watcher.bind(this),100));e.observe(this.options.root||document.body,{childList:!0,subtree:!0,characterData:!0}),this.#e.mutation=e}async watcher(e){console.log("mutated",e);for(const t of e)if(t.type==="childList")for(const i of t.addedNodes)i.nodeType==1&&i instanceof HTMLElement&&(f(i)||l(i).length>0)&&await this.discover()}filterByDirective(e,t){return t?e.filter(i=>i.getAttribute("on")==t):e.filter(i=>!i.hasAttribute("on"))}uniqueByTag(e){const t=new Set,i=[];for(const s of e){const o=s.tagName;t.has(o)||(t.add(o),i.push(s))}return i}clean(){Object.entries(this.#e).map(([e,t])=>t.disconnect()),this.#e={}}async discover(){!this.#t&&this.options.live&&this.watch();for(const t of this.options.directives??[])this.upgrade(t);const e=await this.upgrade();return console.log("finished discover",e),this.#t=!0,e}async upgrade(e){const t=l(this.options.root||document.body),s=this.filterByDirective(t,e);return e==="visible"||this.options.defaultDirective==="visible"?(this.#e.intersection||(this.#e.intersection=new IntersectionObserver(o=>{o.filter(n=>!customElements.get(n.target.tagName.toLowerCase())).filter(n=>n.isIntersecting).map(n=>this.loadAndDefine([n.target],"visible"))})),console.log("observing intersection of",s),s.map(o=>this.#e.intersection.observe(o)),s):e==="interaction"||this.options.defaultDirective==="interaction"?s.map(o=>o.addEventListener("pointerdown",()=>{this.loadAndDefine([o],"interaction")},{once:!0})):e==="eager"||this.options.defaultDirective==="eager"?await this.loadAndDefine(s,"eager"):await this.loadAndDefine(s,"default")}async loadAndDefine(e,t){console.log(`registering from ${t}`,e.map(n=>n.tagName.toLowerCase()));const i=await Promise.allSettled(e.map(n=>this.load(n))),s=i.filter(n=>n.status==="fulfilled"),o=i.filter(n=>n.status==="rejected");return this.options.fallback&&await Promise.allSettled(o.map(n=>{const a=n.reason.details;let u=class extends this.options.fallback{};a.el.setAttribute("error",n.reason.message),a.el.setAttribute("stack",n.reason.stack),this.define({name:a.name,el:a.el,module:u})})),await Promise.allSettled([...s.map(n=>this.define(n.value)),this.flushDefine()]),i}async load(e){const t=e.tagName.toLowerCase();let i=this._catalog[t]||this.getNamespace(t);if(!i)throw new c(`Component ${t} not found in catalog`,{name:t,el:e});let s;try{if(performance.mark(`load:${t}:start`),e.setAttribute("ce-loading",""),typeof i=="string")s=await import(i);else if(typeof i=="function")s=await i(t);else throw new c(`Loader of ${t} is invalid! Should be a url or a function`,{name:t,el:e,module:s})}finally{e.removeAttribute("ce-loading"),performance.mark(`load:${t}:end`),performance.measure(`load:${t}`,`load:${t}:start`,`load:${t}:end`)}return{name:t,module:s,asset:i,el:e}}async define({name:e,el:t,module:i}){if(!customElements.get(e)){if(customElements.waiting[e])i=customElements.waiting[e].ctor;else{if(!i)throw new c(`Component ${e} wasn't registered! This is a bug!!!`,{name:e,el:t,module:i});i=i?.prototype instanceof HTMLElement?i:i?.default}try{performance.mark(`define:${e}:start`),t.setAttribute("ce-defined",""),DEFINE(e,i,{})}finally{performance.mark(`define:${e}:end`),performance.measure(`define:${e}`,`define:${e}:start`,`define:${e}:end`)}return{name:e,module:i}}}getNamespace(e){const[t,i]=e.split("-");return this._namespaces[t]}flushDefine(){console.log("flushDefine()",Object.keys(customElements.waiting)),Object.keys(customElements.waiting).length>0&&Object.entries(customElements.waiting).filter(([e])=>!customElements.get(e)).map(([e,{ctor:t,options:i}])=>DEFINE(e,t,i))}}function m(){globalThis._DEFINE=customElements.define.bind(customElements),globalThis.DEFINE=(r,e,t)=>{globalThis._DEFINE(r,e,t),customElements.registered[r]={ctor:e,options:t},delete customElements.waiting[r]},customElements.waiting={},customElements.registered={},customElements.define=function(r,e,t){customElements.waiting[r]={ctor:e,options:t}}}export{g as C};
